package com.distributedscheduler.service.idempotency;

import com.distributedscheduler.dto.TaskRequest;

import java.time.Duration;
import java.util.Optional;

public interface IdempotencyService {

    /**
     * Builds a Redis key for idempotency check based on tenant ID and request or provided key.
     *
     * @param tenantId        the tenant identifier
     * @param idempotencyKey  the optional key from client
     * @param request         the task request
     * @return formatted Redis key string
     */
    String buildKey(String tenantId, String idempotencyKey, TaskRequest request);

    /**
     * Retrieves the task ID associated with the idempotency key if it exists in Redis.
     *
     * @param key the Redis key
     * @return Optional containing task ID if found
     */
    Optional<String> getTaskIdForKey(String key);

    /**
     * Stores the mapping between an idempotency key and task ID with a TTL.
     *
     * @param key     the Redis key
     * @param taskId  the associated task ID
     * @param ttl     time-to-live duration
     */
    void storeKeyToTaskIdMapping(String key, String taskId, Duration ttl);
}



/**
 * About this component
 *
 * This `IdempotencyService` interface defines a **contract for ensuring idempotent task creation** in a distributed system using Redis.
 *
 * ---
 *
 * ### ✅ **Purpose**
 *
 * To prevent duplicate task creation when a client retries a request (e.g., due to timeout or network issue) **with the same idempotency key**.
 *
 * ---
 *
 * ### 🔧 **Methods Explained**
 *
 * | Method                         | Purpose                                                                                            |
 * | ------------------------------ | -------------------------------------------------------------------------------------------------- |
 * | `buildKey(...)`                | Generates a unique Redis key using tenant ID + client-supplied idempotency key or request details. |
 * | `getTaskIdForKey(String key)`  | Checks if a task was already created for a given idempotency key — prevents duplicate.             |
 * | `storeKeyToTaskIdMapping(...)` | Saves the mapping (idempotency key → task ID) in Redis with TTL (time-to-live).                    |
 *
 * ---
 *
 * ### 🧠 **Example Use Case**
 *
 * When a client submits:
 *
 * ```json
 * {
 *   "idempotencyKey": "req-123",
 *   "name": "SendEmail"
 * }
 * ```
 *
 * 1. Server builds Redis key like:
 *    `idempotency:tenant1:req-123`
 *
 * 2. Checks Redis:
 *
 *    * If key exists → return existing task ID.
 *    * If key doesn't exist → create new task and store mapping in Redis.
 *
 * ---
 *
 * ### ✅ Ensures:
 *
 * * **Idempotent behavior** (safe re-submissions)
 * * **No duplicate tasks** on retry
 * * **TTL** ensures temporary storage to prevent memory leaks
 *
 * ---
 *
 * Let me know if you want the actual implementation too.
 *
 *
 *
 * **/


/**
 * Q.what about taskid, thats unique . Then why idepotency key needed
 *
 *Ans:
 *
 *
 * Good question. Even though `taskId` is unique, **idempotency keys are still needed** because:
 *
 * ---
 *
 * ### 🔁 **Scenario: Client Retry**
 *
 * Suppose a client sends a task creation request, but the network times out, and the client doesn't receive a response. So it **retries** the same request.
 *
 * * ❌ If no idempotency key is used → the server will **generate a new `taskId`** and **create a duplicate task**.
 * * ✅ If an idempotency key like `"req-123"` is sent → the server checks Redis, finds it was already processed, and **returns the original taskId**.
 *
 * ---
 *
 * ### 🎯 **Why `taskId` alone is not enough**
 *
 * * `taskId` is **generated by the server**, so the client has no control or awareness of it during retries.
 * * `idempotencyKey` is **provided by the client** and acts as a consistent reference across retries.
 *
 * ---
 *
 * ### 🛡️ Final Benefit:
 *
 * Idempotency key ensures:
 *
 * * **safe retries**
 * * **no duplication**
 * * **predictable behavior in distributed systems**
 *
 * Let me know if you want a real-world analogy.
 *
 * **/